import { Injectable } from '@angular/core';
import { LoadingController } from '@ionic/angular/standalone';
import { getInterfaces, NetworkInterface as TauriNetworkInterface } from "tauri-plugin-network-api";
import { invoke } from '@tauri-apps/api/core';
import { HttpClient } from '@angular/common/http';
import { firstValueFrom } from 'rxjs';

import { 
  writeTextFile, 
  readTextFile, 
  BaseDirectory, 
  exists,
  remove,
  readDir,
  mkdir
} from '@tauri-apps/plugin-fs';

import { Helpers } from '../helpers';
import { Shell } from '../utils/shell';
import { InterfaceFile } from '../utils/interfaces.file';
import { WPASupplicantFile } from '../utils/wpa-supplicant.file';
import { environment } from '../../environments/environment';

export enum RemoteLookupCommand {
  CMD_FREE_QUERY_REMOTE = 1000,
  CMD_FREE_QUERY = 1001,
  CMD_FREE_QUERY_FAST = 1002,
  CMD_FREE_QUERY_JSONARRAY = 1003,
}

export interface NetworkInterface {
  name: string;
  type: 'wired' | 'wireless';
  mode: 'dhcp' | 'static';
  macAddress: string | null;
  address: string  | null;
  netmask: string | null;
  gateway: string | null;
  configured: boolean;
  connected: boolean;
  _interfaceFile: InterfaceFile;
  _wpaSupplicantFile: WPASupplicantFile;
}

@Injectable({
  providedIn: 'root',
})
export class NetworkService {

  public INTERFACES_FILE = environment.production ? `/etc/network/interfaces` : `/tmp/interfaces`;
  public INTERFACES_FOLDER = environment.production ? `/etc/network/interfaces.d` : `/tmp/interfaces.d`;

  checkAddressTimeout: any = null;
  checkingAddress: boolean = false;

  networkInterfaces: Record<string, NetworkInterface> = {};

  constructor(
    private _httpClient: HttpClient,
    private _loadingCtrl: LoadingController,
  ) {}

  async initialize() {
    await this.loadNetworkInterfaces();
  }

  async onSaveInterfaces(_formGroups: Record<string, any>) {
    console.log('Saving network interfaces...');

    try {
      if (!await exists(this.INTERFACES_FOLDER)) {
        await mkdir(this.INTERFACES_FOLDER, { recursive: true });
      }
    } catch (error) {
      console.error('Error creating interfaces folder:', error);      
    }

    try {
      let _content = `# This file is auto-generated by ElvisPOS Setup Utility. DO NOT EDIT MANUALLY!\n\n`;
      _content += `source-directory ${this.INTERFACES_FOLDER}\n`;
      await writeTextFile(this.INTERFACES_FILE, _content);
    } catch (error) {
      console.error('Error creating interfaces folder:', error);      
    }

    try {
      const _loopbackFilePath = `${this.INTERFACES_FOLDER}/lo`;
      let _content = `# This file is auto-generated by ElvisPOS Setup Utility. DO NOT EDIT MANUALLY!\n\n`;
      _content += `auto lo\n`;
      _content += `iface lo inet loopback\n\n`;
      await writeTextFile(_loopbackFilePath, _content);
    } catch (error) {
      console.error('Error creating interfaces folder:', error);      
    }

    for (const _formGroupKey of Object.keys(_formGroups)) {
      const _formGroup = _formGroups[_formGroupKey];
      const _interface = this.networkInterfaces[_formGroupKey];

      if (!_interface || !_formGroup) {
        console.warn(`No interface or form group found for key: ${_formGroupKey}`);
        continue;
      }

      _interface.configured = true;
      _interface.address = _formGroup.get('address')?.value;
      _interface.netmask = _formGroup.get('netmask')?.value;
      _interface.gateway = _formGroup.get('gateway')?.value;

      console.log(`Interface ${_interface.name} - Address: ${_interface.address}, Netmask: ${_interface.netmask}, Gateway: ${_interface.gateway}`);
      await _interface._interfaceFile.onSave(_interface);

      if (_interface._wpaSupplicantFile) {
        _interface._wpaSupplicantFile.network.ssid = _formGroup.get('wifi_ssid')?.value;
        _interface._wpaSupplicantFile.network.psk = _formGroup.get('wifi_password')?.value;
        await _interface._wpaSupplicantFile.save();
      }
    }
  }

  async checkPort(host: string, port: number): Promise<boolean> {
    try {
      console.log(`Checking port ${port} on host ${host}...`);
      return await invoke<boolean>('check_port', { host, port });
    } catch (error) {
      return false;
    }
  }

  async checkPorts(host: string, ports: number[]): Promise<number[]> {
    try {
      console.log(`Checking ports ${ports.join(', ')} on host ${host}...`);
      return await invoke<number[]>('check_ports', { host, ports });
    } catch (error) {
      return [];
    }
  }

  async remoteLookup(command: RemoteLookupCommand, query: string, host = 'memphisserver'): Promise<any> {
    try {
      const _resp = await firstValueFrom(
        this._httpClient.post(
          `http://${host}:7392/api/db-operations/remote-lookup`, 
          { request: { query: query, command: command }}
        )
      );

      return _resp;
    } catch (error) {
      return null;
    }
  }

  async getServersOnNetworks() {
    // const _confirm = await this.askConfirm(`Scan Network`, `Are you sure you want to install scan your local networks for Servers? This may take a few minutes.`);

    // if (!_confirm) {
    //   return;
    // }

    const _loading = await this._loadingCtrl.create({
      message: 'Searching LAN for Servers...'
    });

    await _loading.present();
    const _results = await this.scanNetworksForServer();
    await _loading.dismiss();

    return _results;
  }

  // private 

  private async loadNetworkInterfaces() {
    let _interfaces = await getInterfaces();

    _interfaces = _interfaces.filter(ni => 
      !(
        ni.name.startsWith('docker') ||
        ni.name.startsWith('veth') ||
        ni.name.startsWith('virbr') ||
        ni.name.startsWith('br-') ||
        ni.name.startsWith('tun') ||
        ni.name.startsWith('snx-') ||
        ni.name === 'lo'
      )
    );

    _interfaces = Helpers.sortByKey(_interfaces, 'name');

    for (const _interface of _interfaces) {
      this.networkInterfaces[_interface.name] = await this.getInterfaceInfo(_interface);
    }

    console.log('Network Interfaces:', this.networkInterfaces);
  }

  private async getInterfaceInfo(_interface: TauriNetworkInterface): Promise<any> {
    const _mappedInterface: any = {
      connected: false,
      type: 'wired',
      name: _interface.name,
      mode: 'dhcp',
      macAddress: _interface.mac_addr,
      address: null,
      netmask: null,
      gateway: null,
    };

    try {
      const _res = await Shell.run(`ls /sys/class/net/${_interface.name}/wireless`);
      _mappedInterface.type = _res.code === 0 ? 'wireless' : 'wired';
    } catch (error) { 
      console.error(error);
    }

    try {
      const _res = await Shell.run(`cat /sys/class/net/${_interface.name}/operstate`);
      _mappedInterface.connected = _res.code === 0 && _res.stdout.trim() === 'up';
    } catch (error) { 
      console.error(error);
    }

    const _routeInfo = await Shell.run(`ip route show dev ${_interface.name} | awk '/default/ {print $3}'`)

    _mappedInterface.gateway = _routeInfo.code === 0 && _routeInfo.stdout.trim().length > 0 ? _routeInfo.stdout.trim() : null;
    _mappedInterface.address = _interface.v4_addrs.length > 0 ? _interface.v4_addrs[0].ip! : null;
    _mappedInterface.netmask = _interface.v4_addrs.length > 0 ? _interface.v4_addrs[0].netmask! : null;

    const _interfaceFilePath = (environment.production ? `/etc/network/interfaces.d/` : `/tmp/interfaces.d/`) + _interface.name;
    _mappedInterface._interfaceFile = new InterfaceFile(_interfaceFilePath);
    const _infoFromFile = await _mappedInterface._interfaceFile.getInterfaceInfo(_interface.name);

    if (_infoFromFile) {
      _mappedInterface.mode = _infoFromFile.method === 'static' ? 'static' : 'dhcp';
      _mappedInterface.address = _infoFromFile.address;
      _mappedInterface.netmask = _infoFromFile.netmask;
      _mappedInterface.gateway = _infoFromFile.gateway;
    } else {
      console.warn(`No info from file for interface ${_interface.name}!`);
    }

    if (_mappedInterface.type === 'wireless') {
      _mappedInterface._wpaSupplicantFile = new WPASupplicantFile(`/tmp/wpa_supplicant-${_interface.name}.conf`);
      await _mappedInterface._wpaSupplicantFile.load();
    }

    if (_infoFromFile?.mode === 'static') {
      _mappedInterface.configured = true;
    }

    return _mappedInterface;
  }

  private async scanNetworksForServer() {
    const _interfaces = await getInterfaces();

    let _foundServers: {
      host: string;
    }[] = [];

    for (const _interface of _interfaces) {
      if (
        _interface.name.startsWith('docker') ||
        _interface.name.startsWith('veth') ||
        _interface.name.startsWith('virbr') ||
        _interface.name.startsWith('br-') ||
        _interface.name.startsWith('snx-') ||
        _interface.name === 'lo'
      ) {
        continue;
      }

      if (_interface.v4_addrs.length === 0) {
        continue;
      }

      console.log(`Scanning interface: ${_interface.name} - ${_interface.v4_addrs[0].ip}`);

      const _subnet = _interface.v4_addrs[0].ip.split('.').slice(0, 3).join('.');
      const _hosts = Array.from({ length: 255 }, (_, i) => `${_subnet}.${i + 1}`);

      console.log(`Starting scan of ${_hosts.length} IPs on ${_subnet}.x...`);

      const _ports = [7392, 873];
      const _checks = _hosts.map(host => invoke<number[]>('check_ports', { host, ports: _ports }).then(openPorts => ({ host, valid: openPorts.length === _ports.length })) );
      const _results = await Promise.all(_checks);
      const _foundIPs = _results.filter(res => res.valid).map(res => res.host);

      console.log(`Results for ${_subnet}.x : ${_foundIPs.length > 0 ? _foundIPs.join(', ') : 'no servers found.'}`);

      return _results.filter(res => res.valid).map(res => ({ host: res.host }));
    }

    return _foundServers;
  }

  
}
