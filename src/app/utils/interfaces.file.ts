import { 
  writeTextFile, 
  readTextFile, 
  BaseDirectory, 
  exists,
  remove,
  readDir
} from '@tauri-apps/plugin-fs';

import { NetworkInterface } from '../services/network-service';

export interface InterfaceConfig {
  name: string;
  method: 'dhcp' | 'static' | 'manual' | 'loopback' | 'unknown';
  address?: string; // IP Address
  netmask?: string;
  gateway?: string;
}

export class InterfaceFile {

  public filePath: string;

  /**
   * @param filePath - Path to the interfaces file (default: /etc/network/interfaces)
   */
  constructor(filePath: string = '/etc/network/interfaces') {
    this.filePath = filePath;
  }

  /**
   * Reads configuration for a specific interface.
   * @param interfaceName - The name of the interface (e.g., 'eth0', 'ens33')
   * @returns Promise resolving to the configuration object or null if not found.
   */
  public async getInterfaceInfo(interfaceName: string): Promise<InterfaceConfig | null> {
    try {
      // Check if file exists
      const _exists = await exists(this.filePath);

      if (!_exists) {
        return null;
      }
      
      const fileContent = await readTextFile(this.filePath);
      const lines = fileContent.split('\n');

      let currentConfig: InterfaceConfig | null = null;
      let insideTargetBlock = false;

      // Regex to identify the start of an iface definition
      // Matches: iface <name> inet <method>
      const ifaceStartRegex = /^\s*iface\s+(\S+)\s+inet\s+(\S+)/;
      
      // Regex to identify the start of any new block (to stop parsing)
      // Stops at: auto, allow-hotplug, iface, mapping, source
      const blockStartRegex = /^\s*(auto|allow-hotplug|iface|mapping|source)\s+/;

      for (let line of lines) {
        // Strip comments and trim whitespace
        const cleanLine = line.split('#')[0].trim();
        if (!cleanLine) continue;

        const ifaceMatch = cleanLine.match(ifaceStartRegex);

        // 1. Check if we found an 'iface' definition line
        if (ifaceMatch) {
          const foundName = ifaceMatch[1];
          const foundMethod = ifaceMatch[2];

          if (foundName === interfaceName) {
            // We found our target, initialize the config object
            insideTargetBlock = true;
            currentConfig = {
              name: interfaceName,
              method: foundMethod as InterfaceConfig['method'],
            };
            continue; // Move to next line to find attributes
          } else {
            // We found a different interface, stop capturing if we were capturing
            if (insideTargetBlock) break;
          }
        }

        // 2. Check if we hit a new block keyword (auto, etc) while inside our target
        if (insideTargetBlock && blockStartRegex.test(cleanLine)) {
          // If we see 'auto eth0' or another 'iface', our block is done.
          // Note: The logic above handles 'iface', this handles 'auto/mapping/etc'
          break; 
        }

        // 3. Extract attributes if we are inside the target block
        if (insideTargetBlock && currentConfig) {
          const parts = cleanLine.split(/\s+/);
          const key = parts[0];
          const value = parts[1];

          switch (key) {
            case 'address':
              currentConfig.address = value;
              break;
            case 'netmask':
              currentConfig.netmask = value;
              break;
            case 'gateway':
              currentConfig.gateway = value;
              break;
          }
        }
      }

      return currentConfig;
    } catch (error) {
      console.error(`Error reading interface info for ${interfaceName}:`, error);
    }

    return null;
  }

  async onSave(_interface: NetworkInterface): Promise<void> {
    let _fileContent = `# This file is auto-generated by ElvisPOS Setup Utility. DO NOT EDIT MANUALLY!\n\n`;
    
    let _mode = 'dhcp';

    if (_interface.address && _interface.netmask && _interface.gateway) {
      _mode = 'static';
    }

    _fileContent += `auto ${_interface.name}\n`;
    _fileContent += `allow-hotplug ${_interface.name}\n`;
    _fileContent += `iface ${_interface.name} inet ${_mode}\n`;

    if (_interface.type === 'wireless' && _interface._wpaSupplicantFile) {
      _fileContent += `  wpa-conf ${_interface._wpaSupplicantFile.filePath}\n`;
    }

    if (_mode === 'static') {
      _fileContent += `  address ${_interface.address}\n`;
      _fileContent += `  netmask ${_interface.netmask}\n`;
      
      if (_interface.gateway) {
        _fileContent += `  gateway ${_interface.gateway}\n`;
      }
    }

    _fileContent += `\n`;

    try {
      await writeTextFile(this.filePath, _fileContent);
      console.log(`Interface configuration saved to ${this.filePath}`);
    } catch (error) {
      console.error(`Error writing interface file:`, error);
    }
  }
}